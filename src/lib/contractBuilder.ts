/**
 * Contract Builder - Generates human-readable settlement agreements
 */

import { PSLangOutput } from "./pslangCompiler";
import { VerdictData } from "@/types/pipeline";

export interface ContractTerms {
  contractText: string;
  termsHash: string;
  agreementId: string;
}

export interface AgreementMetadata {
  caseHash: string;
  evidenceRoot: string;
  deadline?: string;
}

/**
 * Generate a human-readable settlement contract
 */
export async function generateContract(
  transcript: string,
  caseSummary: PSLangOutput,
  verdict: VerdictData,
  metadata: AgreementMetadata
): Promise<ContractTerms> {
  const { decision, confidence, rationale } = verdict;
  const { actor, claim, value, context, hash: caseHash } = caseSummary;
  
  // Normalize rationale to array
  const rationaleArray = Array.isArray(rationale) ? rationale : [rationale];

  // Build readable contract text
  const contractLines: string[] = [];

  contractLines.push("SETTLEMENT AGREEMENT");
  contractLines.push("=".repeat(50));
  contractLines.push("");

  contractLines.push("CASE SUMMARY:");
  contractLines.push(`- Dispute: ${claim}`);
  contractLines.push(`- Claimant: ${actor}`);
  if (value) {
    contractLines.push(`- Amount: ${value}`);
  }
  contractLines.push(`- Context: ${context.substring(0, 200)}${context.length > 200 ? "..." : ""}`);
  contractLines.push("");

  contractLines.push("DECISION:");
  contractLines.push(`- Outcome: ${decision}`);
  contractLines.push(`- Confidence: ${confidence}%`);
  contractLines.push("");
  contractLines.push("Key Points:");
  rationaleArray.slice(0, 3).forEach((point, i) => {
    contractLines.push(`  ${i + 1}. ${point}`);
  });
  contractLines.push("");

  contractLines.push("TERMS:");
  if (decision === "APPROVE") {
    contractLines.push("- The claim is APPROVED.");
    if (value) {
      contractLines.push(`- Settlement amount: ${value}`);
      contractLines.push("- Payment must be completed within 7 days.");
    }
  } else if (decision === "PARTIAL") {
    contractLines.push("- The claim is PARTIALLY APPROVED.");
    if (value) {
      const partialAmount = value.replace(/[₹$,\s]/g, "");
      const numAmount = parseFloat(partialAmount);
      if (!isNaN(numAmount)) {
        const partial = Math.floor(numAmount * 0.5);
        contractLines.push(`- Partial settlement: ₹${partial}`);
        contractLines.push("- Payment must be completed within 7 days.");
      }
    }
  } else {
    contractLines.push("- The claim is REJECTED.");
    contractLines.push("- No payment required.");
  }
  contractLines.push("");

  contractLines.push("EVIDENCE:");
  contractLines.push(`- Evidence Root: ${metadata.evidenceRoot.slice(0, 16)}...`);
  contractLines.push("");

  if (metadata.deadline) {
    contractLines.push(`DEADLINE: ${metadata.deadline}`);
    contractLines.push("");
  }

  contractLines.push("SIGNATURES:");
  contractLines.push("- Both parties must sign this agreement.");
  contractLines.push("- Agreement becomes binding upon both signatures.");
  contractLines.push("");

  contractLines.push("AGREEMENT ID:");
  contractLines.push(`- ${metadata.caseHash.slice(0, 16)}...`);
  contractLines.push("");

  contractLines.push("=".repeat(50));
  contractLines.push("Generated by VERBA Protocol");
  contractLines.push(`Date: ${new Date().toISOString().split("T")[0]}`);

  const contractText = contractLines.join("\n");

  // Generate hashes (async)
  // Note: This function should be called with await in the component
  // For now, we'll use sync version and update component to use async
  const termsHash = await generateHashAsync(contractText);
  const agreementId = await generateHashAsync(metadata.caseHash + termsHash);

  return {
    contractText,
    termsHash,
    agreementId,
  };
}

/**
 * Generate SHA-256 hash
 */
function generateHash(input: string): string {
  // Use Web Crypto API for browser compatibility
  const encoder = new TextEncoder();
  const data = encoder.encode(input);
  
  // For now, use a simple hash (in production, use crypto.subtle.digest)
  // This is a placeholder - in real implementation, use async crypto.subtle.digest
  let hash = 0;
  for (let i = 0; i < data.length; i++) {
    const char = data[i];
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  const hex = Math.abs(hash).toString(16).padStart(16, "0");
  return "0x" + hex.repeat(4).substring(0, 64);
}

/**
 * Async version using crypto.subtle (for production)
 */
export async function generateHashAsync(input: string): Promise<string> {
  if (typeof window === "undefined" || !window.crypto?.subtle) {
    // Fallback for SSR
    return generateHash(input);
  }

  const encoder = new TextEncoder();
  const data = encoder.encode(input);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
  return "0x" + hashHex;
}

